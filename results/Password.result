maude tool: 'maude'
 checking version: 2.7.1. OK.
 checking installation: [Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
[Saturating Sources] Step 1/5
[Saturating Sources] Step 2/5
OK.
theory Password begin

// Function signature and definition of the equational theory E

functions: fst/1, pair/2, pk/1, sign/2, snd/1, true/0, verify/3
equations:
    fst(<x.1, x.2>) = x.1,
    snd(<x.1, x.2>) = x.2,
    verify(sign(x.1, x.2), x.1, pk(x.2)) = true







restriction Equality:
  "∀ x y #i. (Eq( x, y ) @ #i) ⇒ (x = y)"
  // safety formula

restriction Inequality:
  "∀ x y #i. (Neq( x, y ) @ #i) ⇒ (¬(x = y))"
  // safety formula

restriction OnlyOnce:
  "∀ x #i #j. ((OnlyOnce( x ) @ #i) ∧ (OnlyOnce( x ) @ #j)) ⇒ (#i = #j)"
  // safety formula

rule (modulo E) CreateUser:
   [ Fr( ~pw ) ]
  --[ OnlyOnce( $U ), Neq( $U, 'I' ) ]->
   [ !UserID( $U ), !UserAndPW( $U, ~pw ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) CreateBrowser:
   [ ]
  --[ OnlyOnce( $B ), Neq( $B, 'I' ) ]->
   [ !BrowserID( $B ), Corruptible( $B ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) CreateServer:
   [ ]
  --[ OnlyOnce( $S ), Neq( $S, 'I' ) ]->
   [ !ServerID( $S ), !WebPage( $S ), Corruptible( $S ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) CreateIdentityProvider:
   [ Fr( ~skI ) ]
  --[ OnlyOnce( 'I' ) ]->
   [ !Isk( ~skI ), !Ipk( pk(~skI) ), !WebPage( 'I' ), Out( pk(~skI) ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) HonestAgent:
   [ Corruptible( A ) ] --[ Honest( A ) ]-> [ !HonestID( A ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) DishonestAgent:
   [ Corruptible( A ) ] --[ Dishonest( A ) ]-> [ !CorruptID( A ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) AdvSend:
   [ In( <X, m> ), !CorruptID( A ) ] --> [ Msg( A, X, m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) AdvReceive:
   [ Msg( X, A, m ), !CorruptID( A ) ] --> [ Out( m ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) User_0:
   [ !UserID( U ), !UserAndPW( U, pw ), !BrowserID( B ) ]
  --[ TraceU0( U, B ), OnlyOnce( <U, B> ), TalksToBrowser( U, B ) ]->
   [ User_0( U, B, pw ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Browser_0:
   [ !BrowserID( B ), !HonestID( B ), !UserID( U ), !ServerID( S ) ]
  --[ OnlyOnce( <B, 'Start'> ), TraceB0( U, B, S ) ]->
   [ Browser_0( B, U, S ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Server_0:
   [ !ServerID( S ), !HonestID( S ) ] --[ TraceS0( S ) ]-> [ Server_0( S ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdentityProvider_0:
   [ !Isk( skI ) ] --[ TraceI0( 'I' ) ]-> [ IdentityProvider_0( skI ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Browser_1:
   [ Browser_0( B, U, S ) ]
  --[ TraceB1( U, B, S ) ]->
   [ Msg( B, S, '1' ), Browser_1( B, U, S ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Server_1:
   [ Fr( ~cid ), Msg( B, S, '1' ), !BrowserID( B ), Server_0( S ) ]
  --[ TraceS1( ~cid, B, S ) ]->
   [ Msg( S, B, <'2', ~cid, 'I'> ), Server_1( S, ~cid, B ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Browser_2:
   [ Msg( S, B, <'2', cid, SI> ), !WebPage( SI ), Browser_1( B, U, S ) ]
  --[ TraceB2( cid, U, B, S, SI ) ]->
   [ Msg( B, SI, <'3', cid, S> ), Browser_2( B, cid, U, SI ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdentityProvider_1:
   [
   Msg( B, 'I', <'3', cid, S> ), !BrowserID( B ), !ServerID( S ),
   IdentityProvider_0( skI )
   ]
  --[ OnlyOnce( cid ), TraceI1( cid, B, S ) ]->
   [ Msg( 'I', B, <'4', cid, S> ), IdentityProvider_1( cid, B, S, skI ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Browser_3:
   [ Msg( SI, B, <'4', cid, S> ), Browser_2( B, cid, U, SI ) ]
  --[ TraceB3( cid, U, B, S, SI ) ]->
   [ Msg( B, U, <'5', cid, SI, S> ), Browser_3( B, cid, U, SI ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) User_1:
   [ Msg( B, U, <'5', cid, SI, S> ), User_0( U, B, pw ) ]
  --[ Decide( U, SI ), IntentU( cid, U, B, S ), TraceU1( cid, U, B, S, SI )
  ]->
   [ Msg( U, B, <'6', pw> ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Browser_4:
   [ Msg( U, B, <'6', pw> ), Browser_3( B, cid, U, SI ) ]
  --[ TraceB4( cid, U, B, SI ) ]->
   [ Msg( B, SI, <'7', cid, U, pw> ), Browser_4( B, cid, U, SI ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) IdentityProvider_2:
   [
   Msg( B, 'I', <'7', cid, U, pw1> ), IdentityProvider_1( cid, B, S, skI ),
   !UserAndPW( U, pw2 )
   ]
  --[ Eq( pw1, pw2 ), TraceI2( cid, U, B, S ) ]->
   [ Msg( 'I', B, <'8', cid, S, sign(<cid, U, S>, skI)> ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Browser_5:
   [ Msg( SI, B, <'8', cid, S, sig> ), Browser_4( B, cid, U, SI ) ]
  --[ TraceB5( cid, U, B, S, SI ) ]->
   [ Msg( B, S, <'9', cid, U, SI, sig> ) ]

  /* has exactly the trivial AC variant */

rule (modulo E) Server_2:
   [
   Msg( B, S, <'9', cid, U, 'I', sig> ), !UserID( U ),
   Server_1( S, cid, B ), !Ipk( pkI )
   ]
  --[
  Eq( verify(sig, <cid, U, S>, pkI), true ), BelieveS( cid, U, B, S ),
  TraceS2( cid, U, B, S )
  ]->
   [ ]

  /*
  rule (modulo AC) Server_2:
     [
     Msg( B, S, <'9', cid, U, 'I', sig> ), !UserID( U ),
     Server_1( S, cid, B ), !Ipk( pkI )
     ]
    --[ Eq( z, true ), BelieveS( cid, U, B, S ), TraceS2( cid, U, B, S ) ]->
     [ ]
    variants (modulo AC)
    1. S     = S.15
       U     = U.16
       cid   = cid.17
       pkI   = pkI.18
       sig   = sig.19
       z     = verify(sig.19, <cid.17, U.16, S.15>, pkI.18)
    
    2. S     = S.22
       U     = U.23
       cid   = cid.24
       pkI   = pk(x.41)
       sig   = sign(<cid.24, U.23, S.22>, x.41)
       z     = true
  */

lemma SanityCheck:
  exists-trace
  "∃ cid U B S #tU0 #tU1 #tB0 #tB1 #tB2 #tB3 #tB4 #tB5 #tS0 #tS1 #tS2 #tI0
     #tI1 #tI2.
    (((((((((((((((((((((((((((TraceU0( U, B ) @ #tU0) ∧
                              (TraceU1( cid, U, B, S, 'I' ) @ #tU1)) ∧
                             (TraceB0( U, B, S ) @ #tB0)) ∧
                            (TraceB1( U, B, S ) @ #tB1)) ∧
                           (TraceB2( cid, U, B, S, 'I' ) @ #tB2)) ∧
                          (TraceB3( cid, U, B, S, 'I' ) @ #tB3)) ∧
                         (TraceB4( cid, U, B, 'I' ) @ #tB4)) ∧
                        (TraceB5( cid, U, B, S, 'I' ) @ #tB5)) ∧
                       (TraceS0( S ) @ #tS0)) ∧
                      (TraceS1( cid, B, S ) @ #tS1)) ∧
                     (TraceS2( cid, U, B, S ) @ #tS2)) ∧
                    (TraceI0( 'I' ) @ #tI0)) ∧
                   (TraceI1( cid, B, S ) @ #tI1)) ∧
                  (TraceI2( cid, U, B, S ) @ #tI2)) ∧
                 (#tU0 < #tB1)) ∧
                (#tB0 < #tB1)) ∧
               (#tS0 < #tB1)) ∧
              (#tI0 < #tI1)) ∧
             (#tB1 < #tS1)) ∧
            (#tS1 < #tB2)) ∧
           (#tB2 < #tI1)) ∧
          (#tI1 < #tB3)) ∧
         (#tB3 < #tU1)) ∧
        (#tU1 < #tB4)) ∧
       (#tB4 < #tI2)) ∧
      (#tI2 < #tB5)) ∧
     (#tB5 < #tS2)) ∧
    (¬(∃ X #tX. Dishonest( X ) @ #tX))"
/*
guarded formula characterizing all satisfying traces:
"∃ cid U B S #tU0 #tU1 #tB0 #tB1 #tB2 #tB3 #tB4 #tB5 #tS0 #tS1 #tS2 #tI0
   #tI1 #tI2.
  (TraceU0( U, B ) @ #tU0) ∧
  (TraceU1( cid, U, B, S, 'I' ) @ #tU1) ∧
  (TraceB0( U, B, S ) @ #tB0) ∧
  (TraceB1( U, B, S ) @ #tB1) ∧
  (TraceB2( cid, U, B, S, 'I' ) @ #tB2) ∧
  (TraceB3( cid, U, B, S, 'I' ) @ #tB3) ∧
  (TraceB4( cid, U, B, 'I' ) @ #tB4) ∧
  (TraceB5( cid, U, B, S, 'I' ) @ #tB5) ∧
  (TraceS0( S ) @ #tS0) ∧
  (TraceS1( cid, B, S ) @ #tS1) ∧
  (TraceS2( cid, U, B, S ) @ #tS2) ∧
  (TraceI0( 'I' ) @ #tI0) ∧
  (TraceI1( cid, B, S ) @ #tI1) ∧
  (TraceI2( cid, U, B, S ) @ #tI2)
 ∧
  (#tU0 < #tB1) ∧
  (#tB0 < #tB1) ∧
  (#tS0 < #tB1) ∧
  (#tI0 < #tI1) ∧
  (#tB1 < #tS1) ∧
  (#tS1 < #tB2) ∧
  (#tB2 < #tI1) ∧
  (#tI1 < #tB3) ∧
  (#tB3 < #tU1) ∧
  (#tU1 < #tB4) ∧
  (#tB4 < #tI2) ∧
  (#tI2 < #tB5) ∧
  (#tB5 < #tS2) ∧
  (∀ X #tX. (Dishonest( X ) @ #tX) ⇒ ⊥)"
*/
simplify
solve( !UserID( U ) ▶₀ #tU0 )
  case CreateUser
  solve( !UserAndPW( $U, pw.1 ) ▶₁ #tU0 )
    case CreateUser
    solve( !BrowserID( B ) ▶₂ #tU0 )
      case CreateBrowser
      solve( Msg( $B, $U, <'5', ~cid, 'I', S> ) ▶₀ #tU1 )
        case Browser_3_case_3
        solve( User_0( $U, $B, pw.2 ) ▶₁ #tU1 )
          case User_0
          solve( Browser_0( $B, $U, $S ) ▶₀ #tB1 )
            case Browser_0
            solve( Msg( $S, $B, <'2', ~cid, 'I'> ) ▶₀ #tB2 )
              case Server_1
              solve( Msg( 'I', $B, <'4', ~cid, $S> ) ▶₀ #tB3 )
                case IdentityProvider_1
                solve( Msg( $U, $B, <'6', pw> ) ▶₀ #tB4 )
                  case User_1
                  solve( Browser_3( $B, ~cid, $U, 'I' ) ▶₁ #tB4 )
                    case Browser_3
                    solve( Msg( 'I', $B, <'8', ~cid, $S, sig> ) ▶₀ #tB5 )
                      case IdentityProvider_2
                      solve( Browser_4( $B, ~cid, $U, 'I' ) ▶₁ #tB5 )
                        case Browser_4
                        solve( !ServerID( $S ) ▶₀ #tS0 )
                          case CreateServer
                          solve( !HonestID( $S ) ▶₁ #tS0 )
                            case HonestAgent
                            solve( Msg( $B, $S, <'9', ~cid, $U, 'I', sign(<~cid, $U, $S>, x)>
                                   ) ▶₀ #tS2 )
                              case Browser_5
                              solve( !UserID( $U ) ▶₁ #tS2 )
                                case CreateUser
                                solve( Server_1( $S, ~cid, $B ) ▶₂ #tS2 )
                                  case Server_1
                                  solve( !Ipk( pk(~skI) ) ▶₃ #tS2 )
                                    case CreateIdentityProvider
                                    solve( !Isk( skI.1 ) ▶₀ #tI0 )
                                      case CreateIdentityProvider
                                      solve( Msg( $B, 'I', <'7', ~cid, $U, pw1> ) ▶₀ #tI2 )
                                        case Browser_4
                                        SOLVED // trace found
                                      qed
                                    qed
                                  qed
                                qed
                              qed
                            qed
                          qed
                        qed
                      qed
                    qed
                  qed
                qed
              qed
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma PerfectUser_Aliveness:
  all-traces
  "∀ cid U B S #tS_B.
    ((BelieveS( cid, U, B, S ) @ #tS_B) ∧
     (¬(∃ SI #tU_D. (Decide( U, SI ) @ #tU_D) ∧ (¬(SI = 'I'))))) ⇒
    (∃ B2 S2 #tU_B. (IntentU( cid, U, B2, S2 ) @ #tU_B) ∧ (#tU_B < #tS_B))"
/*
guarded formula characterizing all counter-examples:
"∃ cid U B S #tS_B.
  (BelieveS( cid, U, B, S ) @ #tS_B)
 ∧
  (∀ SI #tU_D. (Decide( U, SI ) @ #tU_D) ⇒ SI = 'I') ∧
  (∀ B2 S2 #tU_B. (IntentU( cid, U, B2, S2 ) @ #tU_B) ⇒ ¬(#tU_B < #tS_B))"
*/
simplify
solve( Msg( B, S, <'9', cid, U, 'I', sign(<cid, U, S>, x)> ) ▶₀ #tS_B )
  case AdvSend_case_1
  solve( !UserID( U ) ▶₁ #tS_B )
    case CreateUser
    solve( Server_1( S, cid, $B ) ▶₂ #tS_B )
      case Server_1
      solve( !Ipk( pk(x) ) ▶₃ #tS_B )
        case CreateIdentityProvider
        solve( !KU( ~cid ) @ #vk.6 )
          case AdvReceive
          solve( !KU( sign(<~cid, $U, $S>, ~skI) ) @ #vk.11 )
            case AdvReceive
            solve( !KU( ~pw ) @ #vk.21 )
              case AdvReceive
              SOLVED // trace found
            qed
          qed
        qed
      qed
    qed
  qed
qed

lemma PerfectUser_HonestBrowser_Security:
  all-traces
  "∀ cid U B S #tS_B.
    (((BelieveS( cid, U, B, S ) @ #tS_B) ∧
      (¬(∃ X #t1 #t2.
          (Dishonest( X ) @ #t1) ∧ (TalksToBrowser( U, X ) @ #t2)))) ∧
     (¬(∃ SI #tU_D. (Decide( U, SI ) @ #tU_D) ∧ (¬(SI = 'I'))))) ⇒
    (∃ B2 #tU_B.
      ((IntentU( cid, U, B2, S ) @ #tU_B) ∧ (#tU_B < #tS_B)) ∧
      ((B = B2) ∨
       (∃ #t1 #t2. (Dishonest( B ) @ #t1) ∧ (Dishonest( B2 ) @ #t2))))"
/*
guarded formula characterizing all counter-examples:
"∃ cid U B S #tS_B.
  (BelieveS( cid, U, B, S ) @ #tS_B)
 ∧
  (∀ X #t1 #t2.
    (Dishonest( X ) @ #t1) ∧ (TalksToBrowser( U, X ) @ #t2) ⇒ ⊥) ∧
  (∀ SI #tU_D. (Decide( U, SI ) @ #tU_D) ⇒ SI = 'I') ∧
  (∀ B2 #tU_B.
    (IntentU( cid, U, B2, S ) @ #tU_B)
   ⇒
    ((¬(#tU_B < #tS_B)) ∨
     ((¬(B = B2)) ∧
      (∀ #t1 #t2. (Dishonest( B ) @ #t1) ∧ (Dishonest( B2 ) @ #t2) ⇒ ⊥))))"
*/
simplify
solve( Msg( B, S, <'9', cid, U, 'I', sign(<cid, U, S>, x)> ) ▶₀ #tS_B )
  case AdvSend_case_1
  solve( !UserID( U ) ▶₁ #tS_B )
    case CreateUser
    solve( Server_1( S, cid, $B ) ▶₂ #tS_B )
      case Server_1
      solve( !Ipk( pk(x) ) ▶₃ #tS_B )
        case CreateIdentityProvider
        solve( !KU( ~cid ) @ #vk.6 )
          case AdvReceive
          solve( !KU( sign(<~cid, $U, $S>, ~skI) ) @ #vk.11 )
            case AdvReceive
            solve( !KU( ~pw ) @ #vk.21 )
              case AdvReceive
              by contradiction /* from formulas */
            qed
          next
            case c_sign
            by solve( !KU( ~skI ) @ #vk.15 )
          qed
        qed
      qed
    qed
  qed
next
  case AdvSend_case_2
  solve( !UserID( U ) ▶₁ #tS_B )
    case CreateUser
    by solve( Server_1( S.1, cid, $S ) ▶₂ #tS_B )
  qed
next
  case Browser_5_case_1
  by contradiction /* from formulas */
next
  case Browser_5_case_2
  by contradiction /* from formulas */
next
  case Browser_5_case_3
  by contradiction /* from formulas */
qed

lemma ImperfectUser_HonestBrowser_Aliveness:
  all-traces
  "∀ cid U B S #tS_B.
    ((BelieveS( cid, U, B, S ) @ #tS_B) ∧
     (¬(∃ X #t1 #t2.
         (Dishonest( X ) @ #t1) ∧ (TalksToBrowser( U, X ) @ #t2)))) ⇒
    (∃ B2 S2 #tU_B. (IntentU( cid, U, B2, S2 ) @ #tU_B) ∧ (#tU_B < #tS_B))"
/*
guarded formula characterizing all counter-examples:
"∃ cid U B S #tS_B.
  (BelieveS( cid, U, B, S ) @ #tS_B)
 ∧
  (∀ X #t1 #t2.
    (Dishonest( X ) @ #t1) ∧ (TalksToBrowser( U, X ) @ #t2) ⇒ ⊥) ∧
  (∀ B2 S2 #tU_B. (IntentU( cid, U, B2, S2 ) @ #tU_B) ⇒ ¬(#tU_B < #tS_B))"
*/
simplify
solve( Msg( B, S, <'9', cid, U, 'I', sign(<cid, U, S>, x)> ) ▶₀ #tS_B )
  case AdvSend_case_1
  solve( !UserID( U ) ▶₁ #tS_B )
    case CreateUser
    solve( Server_1( S, cid, $B ) ▶₂ #tS_B )
      case Server_1
      solve( !Ipk( pk(x) ) ▶₃ #tS_B )
        case CreateIdentityProvider
        solve( !KU( ~cid ) @ #vk.6 )
          case AdvReceive
          solve( !KU( sign(<~cid, $U, $S>, ~skI) ) @ #vk.11 )
            case AdvReceive
            solve( !KU( ~pw ) @ #vk.21 )
              case AdvReceive_case_2
              SOLVED // trace found
            qed
          qed
        qed
      qed
    qed
  qed
qed















/* All wellformedness checks were successful. */

/*
Generated from:
Tamarin version 1.8.0
Maude version 2.7.1
Git revision: UNKNOWN, branch: UNKNOWN
Compiled at: 2023-09-01 12:12:18.719033 UTC
*/

end

==============================================================================
summary of summaries:

analyzed: Password.spthy

  processing time: 123.70s
  
  SanityCheck (exists-trace): verified (22 steps)
  PerfectUser_Aliveness (all-traces): falsified - found trace (9 steps)
  PerfectUser_HonestBrowser_Security (all-traces): verified (15 steps)
  ImperfectUser_HonestBrowser_Aliveness (all-traces): falsified - found trace (9 steps)

==============================================================================
