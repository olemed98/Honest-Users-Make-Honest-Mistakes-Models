theory Password
begin
 
builtins: signing

// Restrictions

restriction Equality:
"
    All x y #i. Eq(x,y) @i ==> x = y
"


restriction Inequality:
"
    All x y #i. Neq(x, y) @i ==> not(x = y)
"


restriction OnlyOnce:
"
    All x #i #j. OnlyOnce(x) @#i & OnlyOnce(x) @#j ==> #i=#j
"

// Creation of Agents

rule CreateUser:
    [ Fr(~pw) ] 
  --[ OnlyOnce($U)
    , Neq($U, 'I')
    ]-> 
    [ !UserID($U)        
    , !UserAndPW($U, ~pw) ]
 
rule CreateBrowser:
    [ ] 
  --[ OnlyOnce($B)
    , Neq($B, 'I')
    ]-> 
    [ !BrowserID($B)
    , Corruptible($B) ]
 
rule CreateServer:
    [ ] 
  --[ OnlyOnce($S)
    , Neq($S, 'I')
    ]-> 
    [ !ServerID($S)
    , !WebPage($S)
    , Corruptible($S) ]
 
rule CreateIdentityProvider:
    [ Fr(~skI) ] 
  --[ OnlyOnce('I') 
    ]-> 
    [ !Isk(~skI)
    , !Ipk(pk(~skI))
    , !WebPage('I')
    , Out(pk(~skI)) ]
 
// Is an agent honest or not (only servers and browsers)
rule HonestAgent:
    [ Corruptible(A) ]
  --[ Honest(A)  
    ]->
    [ !HonestID(A) ]

rule DishonestAgent:
    [ Corruptible(A) ] 
  --[ Dishonest(A)
    ]-> 
    [ !CorruptID(A) ]


// Adversary Capabilities
rule AdvSend:
    [ In(<X, m>)
    , !CorruptID(A)
    ]
  -->
    [ Msg(A, X, m) ]

rule AdvReceive:
    [ Msg(X, A, m)
    , !CorruptID(A) 
    ]
  -->
    [ Out(m) ]


// Initialization

rule User_0:
    [ !UserID(U)
    , !UserAndPW(U, pw)
    , !BrowserID(B)
    ]
  --[ TraceU0(U, B)
    , OnlyOnce(<U, B>)
    , TalksToBrowser(U, B)
    ]->
    [ User_0(U, B, pw) ]

rule Browser_0:
    [ !BrowserID(B)
    , !HonestID(B)
    , !UserID(U)
    , !ServerID(S)
    ]
  --[ OnlyOnce(<B, 'Start'>)
    , TraceB0(U, B, S)
    ]->
    [ Browser_0(B, U, S) ]

rule Server_0:
    [ !ServerID(S)
    , !HonestID(S)
    ]
  --[ TraceS0(S) 
    ]->
    [ Server_0(S) ]

rule IdentityProvider_0:
    [ !Isk(skI) ]
  --[ TraceI0('I') 
    ]->
    [ IdentityProvider_0(skI) ]


// Protocol rules
 
rule Browser_1:
    let
        m1 = <'1'>
    in
    [ Browser_0(B, U, S) ]
  --[ TraceB1(U, B, S)
    ]->
    [ Msg(B, S, m1)
    , Browser_1(B, U, S) ]
 
rule Server_1:
    let
        m1 = <'1'>
        m2 = <'2', ~cid, 'I'>
    in
    [ Fr(~cid)
    , Msg(B, S, m1)
    , !BrowserID(B)
    , Server_0(S) ] 
  --[ TraceS1(~cid, B, S) 
    ]->
    [ Msg(S, B, m2)
    , Server_1(S, ~cid, B)
    ] 
 
rule Browser_2:
    let
        m2 = <'2', cid, SI>
        m3 = <'3', cid, S>
    in
    [ Msg(S, B, m2)
    , !WebPage(SI)
    , Browser_1(B, U, S) ]
  --[ TraceB2(cid, U, B, S, SI) 
    ]->
    [ Msg(B, SI, m3)
    , Browser_2(B, cid, U, SI) ]

rule IdentityProvider_1:
    let
        m3 = <'3', cid, S>
        m4 = <'4', cid, S>
    in
    [ Msg(B, 'I', m3)
    , !BrowserID(B)
    , !ServerID(S)
    , IdentityProvider_0(skI) ]
  --[ OnlyOnce(cid) 
    , TraceI1(cid, B, S)
    ]->
    [ Msg('I', B, m4)
    , IdentityProvider_1(cid, B, S, skI) ]
 
rule Browser_3:
    let
        m4 = <'4', cid, S>
        m5 = <'5', cid, SI, S>
    in
    [ Msg(SI, B, m4)
    , Browser_2(B, cid, U, SI) ]
  --[ TraceB3(cid, U, B, S, SI) 
    ]->
    [ Msg(B, U, m5)
    , Browser_3(B, cid, U, SI) ]

rule User_1:
    let
        m5 = <'5', cid, SI, S>
        m6 = <'6', pw>
    in
    [ Msg(B, U, m5)
    , User_0(U, B, pw) ]
  --[ Decide(U, SI)
    , IntentU(cid, U, B, S)
    , TraceU1(cid, U, B, S, SI)
    ]->
    [ Msg(U, B, m6) ]
 
rule Browser_4:
    let
        m6 = <'6', pw> 
        m7 = <'7', cid, U, pw>
    in
    [ Msg(U, B, m6)
    , Browser_3(B, cid, U, SI) ]
  --[ TraceB4(cid, U, B, SI) 
    ]->
    [ Msg(B, SI, m7)
    , Browser_4(B, cid, U, SI) ]

rule IdentityProvider_2:
    let
        m7 = <'7', cid, U, pw1>                  
        sig = sign(<cid, U, S>, skI)
        m8 = <'8', cid, S, sig>
    in
    [ Msg(B, 'I', m7)
    , IdentityProvider_1(cid, B, S, skI)
    , !UserAndPW(U, pw2) ]
  --[ Eq(pw1, pw2)
    , TraceI2(cid, U, B, S)
    ]->
    [ Msg('I', B, m8) ]

rule Browser_5:
    let
        m8 = <'8', cid, S, sig>
        m9 = <'9', cid, U, SI, sig>
    in
    [ Msg(SI, B, m8)
    , Browser_4(B, cid, U, SI) ] 
  --[ TraceB5(cid, U, B, S, SI) 
    ]->
    [ Msg(B, S, m9) ]
 
rule Server_2:
    let
        m9 = <'9', cid, U, 'I', sig>
        ver = verify(sig, <cid, U, S>, pkI)
    in
    [ Msg(B, S, m9)
    , !UserID(U)
    , Server_1(S, cid, B)
    , !Ipk(pkI)
    ]
  --[ Eq(ver, true)
    , BelieveS(cid, U, B, S)
    , TraceS2(cid, U, B, S) 
    ]->
    []
 
// Sanity Check 

lemma SanityCheck:
    exists-trace
    "
    Ex cid U B S 
    #tU0 #tU1 
    #tB0 #tB1 #tB2 #tB3 #tB4 #tB5 
    #tS0 #tS1 #tS2 
    #tI0 #tI1 #tI2. (
    TraceU0(U, B) @tU0
    & TraceU1(cid, U, B, S, 'I') @tU1
    & TraceB0(U, B, S) @tB0
    & TraceB1(U, B, S) @tB1
    & TraceB2(cid, U, B, S, 'I') @tB2
    & TraceB3(cid, U, B, S, 'I') @tB3
    & TraceB4(cid, U, B, 'I') @tB4
    & TraceB5(cid, U, B, S, 'I') @tB5
    & TraceS0(S) @tS0
    & TraceS1(cid, B, S) @tS1
    & TraceS2(cid, U, B, S) @tS2
    & TraceI0('I') @tI0
    & TraceI1(cid, B, S) @tI1
    & TraceI2(cid, U, B, S) @tI2
    // Initialisation is before protocol
    & tU0 < tB1 & tB0 < tB1 & tS0 < tB1 & tI0 < tI1
    // The protocol follows the run
    & tB1 < tS1
    & tS1 < tB2
    & tB2 < tI1
    & tI1 < tB3
    & tB3 < tU1
    & tU1 < tB4
    & tB4 < tI2
    & tI2 < tB5
    & tB5 < tS2
    & not(Ex X #tX. Dishonest(X) @tX)
    )   
    "

lemma PerfectUser_Aliveness:
    "
    All cid U B S #tS_B. 
    BelieveS(cid, U, B, S) @tS_B 
    //& not(Ex X #t1 #t2. Dishonest(X) @t1 & TalksToBrowser(U, X) @t2)  
    & not(Ex SI #tU_D. 
      Decide(U, SI) @tU_D & (not(SI = 'I')))
    ==> 
    Ex B2 S2 #tU_B. 
    IntentU(cid, U, B2, S2) @tU_B 
    & tU_B < tS_B
    "

lemma PerfectUser_HonestBrowser_Security:
    "
    All cid U B S #tS_B. 
    BelieveS(cid, U, B, S) @tS_B 
    & not(Ex X #t1 #t2. Dishonest(X) @t1 & TalksToBrowser(U, X) @t2)  
    & not(Ex SI #tU_D. 
      Decide(U, SI) @tU_D & (not(SI = 'I')))
    ==> 
    Ex B2 #tU_B. 
    IntentU(cid, U, B2, S) @tU_B 
    & tU_B < tS_B
    & ((B = B2) | (Ex #t1 #t2. Dishonest(B) @t1 & Dishonest(B2) @t2))
    "

lemma ImperfectUser_HonestBrowser_Aliveness:
    "
    All cid U B S #tS_B. 
    BelieveS(cid, U, B, S) @tS_B 
    & not(Ex X #t1 #t2. Dishonest(X) @t1 & TalksToBrowser(U, X) @t2)  
    //& not(Ex SI #tU_D. 
    //  Decide(U, SI) @tU_D & (not(SI = 'I')))
    ==> 
    Ex B2 S2 #tU_B. 
    IntentU(cid, U, B2, S2) @tU_B 
    & tU_B < tS_B
    "

 end
